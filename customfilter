Absolutely! Let’s build a simple “search” custom filter in React that follows AG Grid’s official documentation using the reactive API with useGridFilter. This filter will function as a case-insensitive substring search on a chosen column.

Here’s a step-by-step guide:

⸻

1. Component: SearchFilter.jsx

import React, { useCallback } from 'react';
import { useGridFilter } from 'ag-grid-react';

const SearchFilter = ({ model, onModelChange, getValue }) => {
  // Filtering logic: case-insensitive substring match
  const doesFilterPass = useCallback(({ node }) => {
    const cellValue = getValue(node);
    if (model == null || model === '') return true; // no filter → pass all
    if (cellValue == null) return false;
    return cellValue.toString().toLowerCase().includes(model.toLowerCase());
  }, [model, getValue]);

  // Register filter logic
  useGridFilter({ doesFilterPass });

  return (
    <div style={{ padding: 8 }}>
      <input
        type="text"
        placeholder="Search..."
        value={model || ''}
        onChange={({ target: { value } }) =>
          onModelChange(value === '' ? null : value)
        }
        style={{ width: '100%' }}
      />
    </div>
  );
};

export default SearchFilter;

Explanation:
	•	model & onModelChange props: These link our component to AG Grid’s filtering state. model holds the current filter text (or null), and calling onModelChange updates it. As soon as onModelChange is called, the grid filters immediately.  ￼
	•	doesFilterPass: Defines the matching logic, using getValue(node) to retrieve cell values and checking if they contain the filter text.  ￼
	•	useGridFilter: Essential to register our filter function so AG Grid knows how to apply it.  ￼

⸻

2. Using It in Your Grid — App.jsx

import React, { useState } from 'react';
import { AgGridReact } from 'ag-grid-react';
import SearchFilter from './SearchFilter';

import 'ag-grid-community/styles/ag-grid.css';
import 'ag-grid-community/styles/ag-theme-alpine.css';

const App = () => {
  const [rowData] = useState([
    { name: 'Alice', city: 'London' },
    { name: 'Bob', city: 'Paris' },
    { name: 'Charlie', city: 'New York' },
  ]);

  const [columnDefs] = useState([
    { field: 'name', filter: SearchFilter },  // Direct reference works too
    { field: 'city', filter: 'SearchFilter' } // Or by registering under a name
  ]);

  return (
    <div className="ag-theme-alpine" style={{ height: 400 }}>
      <AgGridReact
        rowData={rowData}
        columnDefs={columnDefs}
        frameworkComponents={{ SearchFilter }}
      />
    </div>
  );
};

export default App;

Here, the “name” column uses our custom search filter; any input filters rows to those whose name contains the entered text.

⸻

3. Option: Using a Named Reference

If you prefer registering under a name:

// In App.jsx
frameworkComponents={{ searchFilter: SearchFilter }}
columnDefs={[
  { field: 'name', filter: 'searchFilter' },
  // ...
]}

This pattern is supported and often clearer in JSON-based configurations.  ￼

⸻

Summary Table

Step	What We Did
1	Created a custom filter component using useGridFilter with model and onModelChange props.
2	Implemented case-insensitive substring matching in doesFilterPass.
3	Registered the component with frameworkComponents and applied it via colDef.filter.


⸻

Optional Next Steps
	•	Floating Filter Support: Add getModelAsString() to display current filter in the floating filter area.
	•	Debouncing: For faster typing UX, debounce calls to onModelChange.
	•	Multiple Columns: Apply this filter to several columns or wrap logic for broader searches.
	•	External Search UI: Alternatively, use AG Grid’s Quick Filter at the grid level with setQuickFilter, which searches across all columns.  ￼

⸻

Let me know if you’d like floating filter integration or enhancements like debouncing or multi-column support—we can extend this as needed!